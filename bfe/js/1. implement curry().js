/**
 * ============================================================================
 * ЗАДАЧА: Implement curry()
 * Источник: BFE.dev #1
 * ============================================================================
 * 
 * ОПИСАНИЕ:
 * Реализовать функцию curry(), которая преобразует функцию так, чтобы её
 * можно было вызывать с аргументами по частям.
 * 
 * ============================================================================
 * КЛЮЧЕВЫЕ КОНЦЕПЦИИ:
 * ============================================================================
 * 
 * 1. КАРРИРОВАНИЕ vs ЧАСТИЧНОЕ ПРИМЕНЕНИЕ:
 *    - Каррирование: можно вызывать многократно пока не передашь все аргументы
 *    - Частичное применение: одноразовое "закрепление" части аргументов
 * 
 * 2. КОНТЕКСТ (this):
 *    - apply/call нужны для сохранения контекста при вызове метода объекта
 *    - fn(...args) потеряет контекст this
 * 
 * ============================================================================
 * РЕШЕНИЕ:
 * ============================================================================
 */

function curry(fn) {
    return function curried(...args) {
        // Если накопленных аргументов достаточно — вызываем оригинальную функцию
        if (args.length >= fn.length) {
            return fn.apply(this, args)
        }

        // Иначе возвращаем функцию, которая накопит ещё аргументы
        return (...restArgs) => curried.apply(this, [...args, ...restArgs])
    }
}

/**
 * ============================================================================
 * ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
 * ============================================================================
 */

// Пример 1: Простая функция
const join = (a, b, c) => `${a}_${b}_${c}`
const curriedJoin = curry(join)

console.log(curriedJoin(1, 2, 3))    // '1_2_3' — все аргументы сразу
console.log(curriedJoin(1)(2, 3))    // '1_2_3' — 1 + 2
console.log(curriedJoin(1, 2)(3))    // '1_2_3' — 2 + 1
console.log(curriedJoin(1)(2)(3))    // '1_2_3' — по одному

// Пример 2: С контекстом this
const obj = {
    name: 'John',
    greet: curry(function (greeting, punctuation) {
        return `${greeting}, ${this.name}${punctuation}`
    })
}
console.log(obj.greet('Hello')('!')) // 'Hello, John!'

/**
 * ============================================================================
 * EDGE CASES:
 * ============================================================================
 *
 * 1. Функция без параметров: fn.length === 0, сразу вызывается
 * 2. Передано больше аргументов чем нужно: лишние игнорируются
 * 3. Пустой вызов curriedFn(): просто возвращает ту же curried функцию
 *
 * ============================================================================
 * АЛЬТЕРНАТИВНЫЕ РЕАЛИЗАЦИИ:
 * ============================================================================
 */

// Вариант с call (аргументы передаются по одному):
// fn.call(this, arg1, arg2, arg3)

// Вариант со spread (теряется контекст this):
// return fn(...args)

// Вариант с bind (создаёт новую функцию с привязанным контекстом):
// return curried.bind(this, ...args)