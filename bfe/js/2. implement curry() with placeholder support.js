/**
 * ============================================================================
 * ЗАДАЧА: Implement curry() with placeholder support
 * Источник: BFE.dev #2
 * Сложность: Medium
 * ============================================================================
 *
 * ОПИСАНИЕ:
 * Расширить функцию curry() так, чтобы она поддерживала placeholder —
 * специальный символ, позволяющий "пропустить" аргумент и передать его позже.
 *
 * ============================================================================
 * КЛЮЧЕВЫЕ КОНЦЕПЦИИ:
 * ============================================================================
 *
 * 1. PLACEHOLDER vs ОБЫЧНЫЙ CURRY:
 *    - Обычный curry: аргументы заполняются строго слева направо
 *    - С placeholder: можно "зарезервировать" любую позицию
 *
 * 2. ПОЧЕМУ Symbol(), а не undefined:
 *    - undefined — валидное значение аргумента
 *    - Symbol() — уникальный идентификатор, который невозможно случайно передать
 *
 * 3. АЛГОРИТМ СЛИЯНИЯ:
 *    - Проходим по накопленным аргументам
 *    - Если встречаем placeholder — заменяем на следующий новый аргумент
 *    - Оставшиеся новые аргументы добавляем в конец
 *
 * 4. ИЗБЕГАНИЕ МУТАЦИИ:
 *    - Создаём копию массива [...args] перед изменением
 *    - Иначе повторные вызовы сломаются
 *
 * 5. ⚠️ ВАЖНО: УСЛОВИЕ ВЫЗОВА fn
 *    - Проверяем только ПЕРВЫЕ fn.length позиций!
 *    - args.slice(0, fn.length) — берём первые N элементов
 *    - Если среди них есть placeholder — НЕ вызываем fn
 *    - Иначе можно случайно передать placeholder как значение
 *
 * ============================================================================
 * РЕШЕНИЕ:
 * ============================================================================
 */

function curry(fn) {
    return function curried(...args) {
        // ⚠️ Проверяем только ПЕРВЫЕ fn.length позиций — есть ли там placeholder
        const firstNArgs = args.slice(0, fn.length)
        const hasNoPlaceholders = firstNArgs.every((arg) => arg !== curry.placeholder)

        // Вызываем fn только если первые N позиций заполнены реальными значениями
        if (firstNArgs.length >= fn.length && hasNoPlaceholders) {
            return fn.apply(this, args)
        }

        // Иначе возвращаем функцию для накопления
        return (...restArgs) => {
            // Копируем чтобы не мутировать оригинал
            const newArgs = [...args]

            // Заменяем placeholder'ы на новые аргументы
            for (let i = 0; i < newArgs.length; i++) {
                if (newArgs[i] === curry.placeholder && restArgs[0] !== undefined) {
                    const arg = restArgs.shift()
                    newArgs[i] = arg
                }
            }

            // Добавляем оставшиеся аргументы и рекурсивно вызываем
            return curried.apply(this, newArgs.concat(restArgs))
        }
    }
}

curry.placeholder = Symbol()

/**
 * ============================================================================
 * ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
 * ============================================================================
 */

const join = (a, b, c) => `${a}_${b}_${c}`
const curriedJoin = curry(join)
const _ = curry.placeholder

// Обычные вызовы (как в curry без placeholder)
console.log(curriedJoin(1, 2, 3))     // '1_2_3'
console.log(curriedJoin(1)(2)(3))     // '1_2_3'

// С placeholder — пропускаем первый аргумент
console.log(curriedJoin(_, 2)(1, 3))  // '1_2_3'

// Сложная цепочка
console.log(curriedJoin(_, _, _)(1)(_, 3)(2))  // '1_2_3'

// Placeholder в середине
console.log(curriedJoin(1, _, 3)(2))  // '1_2_3'

// С falsy значениями (0, false, null — это валидные аргументы!)
console.log(curriedJoin(0, _, _)(false, null))  // '0_false_null'

// ⚠️ Передача placeholder как НОВОГО аргумента (важный edge case!)
console.log(curry(join)(_, _, 3, 4)(1, _)(2, 5))  // '1_2_3'

/**
 * ============================================================================
 * EDGE CASES:
 * ============================================================================
 *
 * 1. Falsy значения (0, false, null, ''): работают как обычные аргументы
 * 2. undefined: проверяем через !== undefined, не через truthiness
 * 3. Повторное использование: благодаря копированию массива работает корректно
 * 4. ⚠️ Placeholder как НОВЫЙ аргумент: curry(join)(_, _)(1, _)(2, 3)
 *    - Placeholder может быть передан как новый аргумент в следующем вызове
 *    - Нужно проверять ПЕРВЫЕ N позиций, а не общее количество
 *
 * ============================================================================
 * ЧАСТЫЕ ОШИБКИ:
 * ============================================================================
 *
 * 1. Использование this.placeholder вместо curry.placeholder
 * 2. Мутация оригинального массива args (нужно копировать)
 * 3. Проверка !!arg вместо arg !== undefined (теряем falsy значения)
 * 4. shift() на каждой итерации, даже если элемент не placeholder
 * 5. args.push(restArgs) вместо args.concat(restArgs) (вложенный массив)
 * 6. ⚠️ Проверка args.filter(...).length вместо args.slice(0, fn.length)
 *    - Нужно проверять именно ПЕРВЫЕ N позиций, не все аргументы!
 *
 * ============================================================================
 */