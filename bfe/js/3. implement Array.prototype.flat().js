/**
 * ============================================================================
 * ЗАДАЧА: Implement Array.prototype.flat()
 * Источник: BFE.dev #3
 * Сложность: Easy
 * ============================================================================
 *
 * ОПИСАНИЕ:
 * Реализовать функцию flat(arr, depth), которая "разворачивает" вложенные
 * массивы на указанную глубину.
 *
 * ============================================================================
 * КЛЮЧЕВЫЕ КОНЦЕПЦИИ:
 * ============================================================================
 *
 * 1. ПАРАМЕТР depth:
 *    - depth = 1 (по умолчанию): разворачивает один уровень вложенности
 *    - depth = 0: не разворачивает, возвращает копию
 *    - depth = Infinity: разворачивает все уровни
 *
 * 2. УСЛОВИЕ РЕКУРСИИ:
 *    - Разворачиваем только если: Array.isArray(element) && depth > 0
 *    - При рекурсии уменьшаем depth на 1
 *
 * 3. ДВА ПОДХОДА:
 *    - Рекурсия: проще для понимания
 *    - Стек: избегает переполнения call stack на глубоких массивах
 *
 * ============================================================================
 * РЕШЕНИЕ 1: РЕКУРСИЯ
 * ============================================================================
 */

function flat(array, depth = 1) {
    const result = []

    for (const element of array) {
        if (Array.isArray(element) && depth > 0) {
            // Рекурсивно разворачиваем вложенный массив
            const flattenedElements = flat(element, depth - 1)
            result.push(...flattenedElements)
        } else {
            // Добавляем элемент как есть
            result.push(element)
        }
    }

    return result
}

/**
 * ============================================================================
 * РЕШЕНИЕ 2: СТЕК (итеративное)
 * ============================================================================
 */

function flatStack(array, depth = 1) {
    // Храним пары [element, currentDepth] — важно для отслеживания глубины
    const stack = array.map(element => [element, depth]).reverse()
    const result = []

    while (stack.length > 0) {
        const [element, currentDepth] = stack.pop()

        if (Array.isArray(element) && currentDepth > 0) {
            // Добавляем элементы в обратном порядке для сохранения порядка
            for (let i = element.length - 1; i >= 0; i--) {
                stack.push([element[i], currentDepth - 1])
            }
        } else {
            result.push(element)
        }
    }

    return result
}

/**
 * ============================================================================
 * ЛУЧШЕЕ РЕШЕНИЕ: reduce + concat
 * ============================================================================
 * Более лаконичный вариант через reduce — хорош для насмотренности
 */

function flatBest(array, depth = 1) {
    return depth > 0
        ? array.reduce((acc, element) =>
            acc.concat(Array.isArray(element) ? flatBest(element, depth - 1) : element), [])
        : array.slice() // depth = 0, возвращаем копию
}

/**
 * ============================================================================
 * ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
 * ============================================================================
 */

const arr = [1, [2], [3, [4]]]

console.log(flat(arr))        // [1, 2, 3, [4]]
console.log(flat(arr, 1))     // [1, 2, 3, [4]]
console.log(flat(arr, 2))     // [1, 2, 3, 4]
console.log(flat(arr, 0))     // [1, [2], [3, [4]]]

console.log(flatStack(arr))   // [1, 2, 3, [4]]
console.log(flatBest(arr, 2)) // [1, 2, 3, 4]

/**
 * ============================================================================
 * EDGE CASES:
 * ============================================================================
 *
 * 1. Пустой массив: flat([], 5) → []
 * 2. Без вложенности: flat([1, 2, 3], 1) → [1, 2, 3]
 * 3. depth = 0: возвращает копию без изменений
 * 4. depth = Infinity: разворачивает полностью
 *
 * ============================================================================
 * ЧАСТЫЕ ОШИБКИ:
 * ============================================================================
 *
 * 1. Забыть условие depth > 0 — бесконечная рекурсия
 * 2. arr.reverse() мутирует массив — использовать [...arr].reverse() или .map().reverse()
 * 3. В стеке: push([...item, depth]) вместо push каждого элемента как пары
 * 4. Неправильный порядок в стеке — забыть reverse
 *
 * ============================================================================
 * СЛОЖНОСТЬ:
 * ============================================================================
 *
 * Время: O(n), где n — общее количество элементов после разворачивания
 * Память: O(n) — результирующий массив + стек/рекурсия
 *
 * ============================================================================
 */